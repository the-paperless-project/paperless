# Generated by Django 2.2.13 on 2020-07-15 14:13

from django.db import migrations, models
import django.db.models.deletion
import django.utils.timezone
from django.conf import settings


class Migration(migrations.Migration):

    dependencies = [
        ('documents', '0023_document_current_filename'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='correspondent',
            options={'ordering': ('name',), 'verbose_name': 'correspondent', 'verbose_name_plural': 'correspondents'},
        ),
        migrations.AlterModelOptions(
            name='document',
            options={'ordering': ('correspondent', 'title'), 'verbose_name': 'document', 'verbose_name_plural': 'documents'},
        ),
        migrations.AlterModelOptions(
            name='log',
            options={'ordering': ('-modified',), 'verbose_name': 'log', 'verbose_name_plural': 'logs'},
        ),
        migrations.AlterModelOptions(
            name='tag',
            options={'verbose_name': 'tag', 'verbose_name_plural': 'tags'},
        ),
        migrations.AlterField(
            model_name='correspondent',
            name='is_insensitive',
            field=models.BooleanField(default=True, verbose_name='is_sensitive'),
        ),
        migrations.AlterField(
            model_name='correspondent',
            name='match',
            field=models.CharField(blank=True, max_length=256, verbose_name='match'),
        ),
        migrations.AlterField(
            model_name='correspondent',
            name='matching_algorithm',
            field=models.PositiveIntegerField(choices=[(1, 'Any'), (2, 'All'), (3, 'Literal'), (4, 'Regular Expression'), (5, 'Fuzzy Match')], default=1, help_text='Which algorithm you want to use when matching text to the OCR\'d PDF.  Here, "any" looks for any occurrence of any word provided in the PDF, while "all" requires that every word provided appear in the PDF, albeit not in the order provided.  A "literal" match means that the text you enter must appear in the PDF exactly as you\'ve entered it, and "regular expression" uses a regex to match the PDF.  (If you don\'t know what a regex is, you probably don\'t want this option.)  Finally, a "fuzzy match" looks for words or phrases that are mostly—but not exactly—the same, which can be useful for matching against documents containg imperfections that foil accurate OCR.', verbose_name='matching algorithm'),
        ),
        migrations.AlterField(
            model_name='document',
            name='added',
            field=models.DateTimeField(db_index=True, default=django.utils.timezone.now, editable=False, verbose_name='added'),
        ),
        migrations.AlterField(
            model_name='document',
            name='checksum',
            field=models.CharField(editable=False, help_text='The checksum of the original document (before it was encrypted).  We use this to prevent duplicate document imports.', max_length=32, unique=True, verbose_name='checksum'),
        ),
        migrations.AlterField(
            model_name='document',
            name='content',
            field=models.TextField(blank=True, db_index=("mysql" not in settings.DATABASES["default"]["ENGINE"]), help_text='The raw, text-only data of the document.  This field is primarily used for searching.', verbose_name='content'),
        ),
        migrations.AlterField(
            model_name='document',
            name='correspondent',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='documents', to='documents.Correspondent', verbose_name='correspondent'),
        ),
        migrations.AlterField(
            model_name='document',
            name='created',
            field=models.DateTimeField(db_index=True, default=django.utils.timezone.now, verbose_name='documentcreated'),
        ),
        migrations.AlterField(
            model_name='document',
            name='file_type',
            field=models.CharField(choices=[('pdf', 'PDF'), ('png', 'PNG'), ('jpg', 'JPG'), ('gif', 'GIF'), ('tiff', 'TIFF'), ('txt', 'TXT'), ('csv', 'CSV'), ('md', 'MD')], editable=False, max_length=4, verbose_name='filetype'),
        ),
        migrations.AlterField(
            model_name='document',
            name='filename',
            field=models.FilePathField(default=None, editable=False, help_text='Current filename in storage', max_length=256, null=True, verbose_name='filename'),
        ),
        migrations.AlterField(
            model_name='document',
            name='modified',
            field=models.DateTimeField(auto_now=True, db_index=True, verbose_name='modified'),
        ),
        migrations.AlterField(
            model_name='document',
            name='storage_type',
            field=models.CharField(choices=[('unencrypted', 'Unencrypted'), ('gpg', 'Encrypted with GNU Privacy Guard')], default='unencrypted', editable=False, max_length=11, verbose_name='storagetype'),
        ),
        migrations.AlterField(
            model_name='document',
            name='tags',
            field=models.ManyToManyField(blank=True, related_name='documents', to='documents.Tag', verbose_name='tags'),
        ),
        migrations.AlterField(
            model_name='document',
            name='title',
            field=models.CharField(blank=True, db_index=True, max_length=128, verbose_name='title'),
        ),
        migrations.AlterField(
            model_name='log',
            name='created',
            field=models.DateTimeField(auto_now_add=True, verbose_name='created'),
        ),
        migrations.AlterField(
            model_name='log',
            name='level',
            field=models.PositiveIntegerField(choices=[(10, 'Debugging'), (20, 'Informational'), (30, 'Warning'), (40, 'Error'), (50, 'Critical')], default=20, verbose_name='level'),
        ),
        migrations.AlterField(
            model_name='log',
            name='message',
            field=models.TextField(verbose_name='message'),
        ),
        migrations.AlterField(
            model_name='log',
            name='modified',
            field=models.DateTimeField(auto_now=True, verbose_name='modified'),
        ),
        migrations.AlterField(
            model_name='tag',
            name='colour',
            field=models.PositiveIntegerField(choices=[(1, '#a6cee3'), (2, '#1f78b4'), (3, '#b2df8a'), (4, '#33a02c'), (5, '#fb9a99'), (6, '#e31a1c'), (7, '#fdbf6f'), (8, '#ff7f00'), (9, '#cab2d6'), (10, '#6a3d9a'), (11, '#b15928'), (12, '#000000'), (13, '#cccccc')], default=1, verbose_name='colour'),
        ),
        migrations.AlterField(
            model_name='tag',
            name='is_insensitive',
            field=models.BooleanField(default=True, verbose_name='is_sensitive'),
        ),
        migrations.AlterField(
            model_name='tag',
            name='match',
            field=models.CharField(blank=True, max_length=256, verbose_name='match'),
        ),
        migrations.AlterField(
            model_name='tag',
            name='matching_algorithm',
            field=models.PositiveIntegerField(choices=[(1, 'Any'), (2, 'All'), (3, 'Literal'), (4, 'Regular Expression'), (5, 'Fuzzy Match')], default=1, help_text='Which algorithm you want to use when matching text to the OCR\'d PDF.  Here, "any" looks for any occurrence of any word provided in the PDF, while "all" requires that every word provided appear in the PDF, albeit not in the order provided.  A "literal" match means that the text you enter must appear in the PDF exactly as you\'ve entered it, and "regular expression" uses a regex to match the PDF.  (If you don\'t know what a regex is, you probably don\'t want this option.)  Finally, a "fuzzy match" looks for words or phrases that are mostly—but not exactly—the same, which can be useful for matching against documents containg imperfections that foil accurate OCR.', verbose_name='matching algorithm'),
        ),
    ]
